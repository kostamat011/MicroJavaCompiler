
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

/****************************************************************************************************/
/* Terminals */

terminal PROG, BREAK, CONT, IF, ELSE, CONST, CLASS, DO, WHILE, NEW;
terminal PRINT, READ, VOID, RETURN, RECORD, ENUM, SUPER, GOTO, THIS, EXT;

terminal PLUS, MINUS, MUL, DIV, PCT, ASSIGN, EQUAL, NOT_EQUAL, GT, GTE, LS, LSE;
terminal AND, OR, PLUSPLUS, MINUSMINUS, SEMICOLON, COMMA, LPAREN, RPAREN;
terminal LBRCK, RBRCK, LBRACE, RBRACE, DBLDOT, DOT;

terminal String IDENT;
terminal Boolean BOOL_CONST;
terminal Character CHAR_CONST;
terminal Integer NUMBER_CONST;

/****************************************************************************************************/
/* Non - Terminals */

/* type */
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;

/* program */
nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgramName;

/* declarations */
nonterminal AllDeclList, SingleDecl;
nonterminal ConstDecl, ConstAssignList, ConstAssign, ConstVal;
nonterminal VarDecl, VarDeclList, VarDeclSingle, VarDeclOption, ArrBracketsOption;
nonterminal GlobalVarDecl, GlobalVarDeclList, GlobalVarDeclSingle;
nonterminal ClassDecl, ClassMethodDeclOption;

/* records */
nonterminal rs.etf.pp1.symboltable.concepts.Obj RecordName;
nonterminal RecordDecl;

/* methods */
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodName;
nonterminal MethodDecl, MethodDeclList, MethodDeclOption, MethodSignature, MethodType;

/* formal parameters */
nonterminal FormParsOption, FormPars, FormPar, VarArgs;

/* statements */
nonterminal StatementList, Statement, Statements, SingleStatement;

/* designators and designator statements */
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator;
nonterminal DesignatorStatement, DesignatorStatementAssign, NumConstOption;

/* expressions, terms, factors */
nonterminal rs.etf.pp1.symboltable.concepts.Obj Expr, Term, Factor;
nonterminal Mulop, Addop;

/* actual parameters */
nonterminal ActPars, ActParsOption, ActParsLeftParen, ActParsRightParen;

/* method call */
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodCall;

/* conditions */
nonterminal Condition, IfCondition, CondTerm, CondFact, Relop;

precedence left ELSE;

/****************************************************************************************************/

Program ::= (Program) PROG ProgramName:progName AllDeclList LBRACE MethodDeclList RBRACE;

ProgramName ::= (ProgramName) IDENT:name;

AllDeclList ::= (AllDeclListMultiple) AllDeclList SingleDecl
				| (NoDecl) /* epsilon */
				;

Type ::= (Type) IDENT:name;

SingleDecl ::= (ConstDeclaration) ConstDecl
			|  (GlobalVarDeclaration) GlobalVarDecl
			|  (RecordDeclaration) RecordDecl
			|  (ClassDeclaration) ClassDecl
			;

ConstDecl ::= (ConstDeclarationExpr) CONST Type:constTypeName ConstAssignList SEMICOLON;

ConstAssignList ::= (ConstAssignListMultiple) ConstAssignList COMMA ConstAssign
				  |	(ConstAssignSingle) ConstAssign
				  ;

ConstAssign ::= (ConstAssign) IDENT:constName ASSIGN ConstVal;

ConstVal ::= (NumberConst) NUMBER_CONST:numVal
			| (CharConst) CHAR_CONST:charVal
			| (BoolConst) BOOL_CONST:boolVal
			;
			
VarDecl ::= (VarDeclarationExpr) Type:varTypeName VarDeclList SEMICOLON;

VarDeclList ::= (VarDeclListMultiple) VarDeclList COMMA VarDeclSingle
			  | (VarDeclListSingle) VarDeclSingle
			  ;

VarDeclSingle ::= (VarDeclSingle) IDENT:varName ArrBracketsOption;

VarDeclOption ::= (VarDeclOptionTrue) VarDeclOption VarDecl
				| (NoVarDeclOption) /* epsilon */ 
				;

GlobalVarDecl ::= (GlobalVarDeclarationExpr) Type:varTypeName GlobalVarDeclList SEMICOLON;

GlobalVarDeclList ::= (GlobalVarDeclListMultiple) GlobalVarDeclList COMMA GlobalVarDeclSingle
			  | (GlobalVarDeclListSingle) GlobalVarDeclSingle
			  ;

GlobalVarDeclSingle ::= (GlobalVarDeclarationSingle) IDENT:varName ArrBracketsOption
					 |  (GlobalVarDeclarationError) error:l
					 {: parser.report_error("Izvrsen oporovak prilikom greske u deklaraciji globalne promenljive do , ili ; u liniji " + lleft, null); :}
					 ;
	

ArrBracketsOption ::= (ArrayBrackets) LBRCK RBRCK
			       |  (NoArray) /* epsilon */
			 	   ;
			 
RecordDecl ::= (RecordDeclarationExpr) RECORD RecordName LBRACE VarDeclOption RBRACE;

RecordName ::= (RecordName) IDENT:name;
				
ClassDecl ::= (ClassDeclarationExpr) CLASS IDENT:className LBRACE VarDeclOption ClassMethodDeclOption RBRACE;

ClassMethodDeclOption ::= (ClassMethodOption) LBRACE MethodDeclOption RBRACE;

MethodDeclList ::= (MethodDeclListMultiple) MethodDeclList MethodDecl
				|  (MethodDeclListNo) /* epsilon */
				;

MethodDecl ::= (MethodDeclaration) MethodSignature VarDeclOption LBRACE StatementList RBRACE;

MethodSignature ::= (MethodSignatureParams) MethodType MethodName LPAREN FormPars RPAREN 
				 |  (MethodSignatureVarArgs) MethodType MethodName LPAREN FormPars COMMA VarArgs RPAREN
				 |  (MethodSignaturePlain) MethodType MethodName LPAREN RPAREN 
				 ;

MethodName ::= (MethodName) IDENT:name;

MethodType ::= (MethodTypeType) Type
			|  (MethodTypeVoid) VOID
			; 

VarArgs ::= (VarArgsDeclaration) Type DOT DOT DOT IDENT:varArgsName;

FormPars ::= (FormParsMultiple) FormPars COMMA FormPar
		   | (FormParsSingle) FormPar
		   ;  
		   
FormPar ::= (FormParSingle) Type:formParTypeName IDENT:formParName ArrBracketsOption
		| (FormParError) error:l
		{: parser.report_error("Izvrsen oporovak prilikom greske u formalnom parametru do , ili ) u liniji " + lleft, null); :} 
		;

Statements ::= (StatementsInBraces) LBRACE StatementList RBRACE;

Statement ::= (StatementSingle) SingleStatement 
			| (StatementMultiple) Statements
			;

StatementList ::= (StatementListMultiple) StatementList Statement
				| (StatementListNo) /* epsilon */
				;

SingleStatement ::= (SingleDesignatorStatement) DesignatorStatement SEMICOLON
				 |  (SingleReadStatement) READ LPAREN Designator RPAREN SEMICOLON
				 |  (SinglePrintStatement) PRINT LPAREN Expr NumConstOption RPAREN SEMICOLON
				 |  (SingleBreakStatement) BREAK SEMICOLON
				 |  (SingleContinueStatement) CONT SEMICOLON
				 |  (SingleReturnStatement) RETURN SEMICOLON
				 |  (SingleReturnExprStatement) RETURN Expr SEMICOLON
				 |  (IfStatement) IF LPAREN IfCondition RPAREN Statement
				 |  (IfElseStatement) IF LPAREN IfCondition RPAREN Statement ELSE Statement
				 |  (DoWhileStatement) DO StatementList WHILE LPAREN Condition RPAREN SEMICOLON
				 ;
				 
NumConstOption ::= (NumConstYes) COMMA NUMBER_CONST
				|  (NumConstNo) /* epsilon */
				;
				
Expr ::= (SingleTermExprPositive) Term 
	  |  (SingleTermExprNegative) MINUS Term 
	  |  (MultiTermExpr) Expr Addop Term
	  ;
	  
Term ::= (SingleFactorTerm) Factor
      |  (MultiFactorTerm) Term Mulop Factor
	  ;

Factor ::= (NumConstFactor) NUMBER_CONST
		| (CharConstFactor) CHAR_CONST
		| (ExprFactor) LPAREN Expr RPAREN
		| (BoolConstFactor) BOOL_CONST
		| (NewTypeFactor) NEW Type LBRCK Expr RBRCK
		| (DesignatorEmptyFactor) Designator
		| (MethodCallFactor) MethodCall
		;

Addop ::= (AddopPlus) PLUS
	   |  (AddopMinus) MINUS
	   ;
	   
Mulop ::= (MulopMul) MUL
	   |  (MulopDiv) DIV
	   |  (MulopPct) PCT
	   ;
	   
Relop ::= (RelopGT) GT
	   |  (RelopGTE) GTE
	   |  (RelopNOTEQUAL) NOT_EQUAL
	   |  (RelopEQUAL) EQUAL
	   |  (RelopLS) LS
	   |  (RelopLSE) LSE
	   ;

Designator ::= (IdentDesignator) IDENT:ident
			|  (IdentArrayDesignator) IDENT:ident LBRCK Expr RBRCK
			|  (IdentMemberDesignator) IDENT:ident DOT IDENT:memberName
			|  (IdentMemberArrayDesignator) IDENT:ident DOT IDENT:memberArrayName LBRCK Expr RBRCK
			;

DesignatorStatement ::= (DesignatorStmtAssign) DesignatorStatementAssign
					|   (DesignatorStmtPlusPlus) Designator PLUSPLUS
					|   (DesignatorStmtMinusMinus) Designator MINUSMINUS
					|   (DesignatorStmtMethodCall) MethodCall
					;

DesignatorStatementAssign ::= (DesignatorStmtAssignCorrect) Designator ASSIGN Expr
							| (AssignError) error:l
							{: parser.report_error("Izvrsen oporovak prilikom greske naredbi dodele do ; u liniji " + lleft, null); :} 
							;
					
ActPars ::= (ActParsMultiExpr) ActPars COMMA Expr
		 |  (ActParsSingleExpr) Expr
		 ;

ActParsOption ::= (ActParsYes) ActPars
				| (ActParsNo) /* epsilon */
				;

ActParsLeftParen ::= (ActParsLeftParen) LPAREN;

ActParsRightParen ::= (ActParsRightParen) RPAREN;

MethodCall ::= (MethodCall) Designator ActParsLeftParen ActParsOption ActParsRightParen;
				
Condition ::= (ConditionSingle) CondTerm
		   |  (ConditionMultiple) Condition OR CondTerm
		   ;
		   
IfCondition ::= (IfConditionSingle) CondTerm
		   |  	(IfConditionMultiple) Condition OR CondTerm
		   |  	(IfConditionError) error:l
			{: parser.report_error("Izvrsen oporovak prilikom greske u logickom izrazu unutar if naredbe do ) u liniji " + lleft, null); :}
		   ;
		   
CondTerm ::= (CondTermListSingle) CondFact
		   | (CondTermListMultiple) CondTerm AND CondFact
		   ;
		   
CondFact ::= (CondFactExpr) Expr
		  |  (CondFactExprRelop) Expr Relop Expr
		  ;
